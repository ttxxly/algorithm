# 给你n个⽆序的int整型数组arr，并且这些整数的取值范围都在0-20之间，要你在 O(n) 的时间复杂度中把这 n 个数按照从⼩到⼤的顺序打印出来。

```text
对于这道题，如果你是先把这 n 个数先排序，再打印，是不可能O(n)的时间打印出来的。但是数值范围
在 0-20。我们就可以巧⽤数组下标了。把对应的数值作为数组下标，如果这个数出现过，则对应的数组
加1

public void f(int arr[]) {
 int[] temp = new int[21];
 for (int i = 0; i < arr.length; i++) {
 temp[arr[i]]++;
 }
 //顺序打印
 for (int i = 0; i < 21; i++) {
 for (int j = 0; j < temp[i]; j++) {
 System.out.println(i);
 }
 }
 }

```

# 假如给你20亿个⾮负数的int型整数，然后再给你⼀个⾮负数的int型整数 t ，让你判断t是否存在于这20亿数中，你会怎么做呢？

```text
1. 下标法
2. 优化：因为如果不需要统计个数，我们我们不需要 int 数组，⽤boolean类型的数组他不⾹吗？boolean类型占⽤的空间更少
3. bitmap 算法
```

# 双指针

```text
双指针这个技巧，那就更加常⽤的，特别是在链表和有序数组中，例如

给定⼀个整数有序数组和⼀个⽬标值，找出数组中和为⽬标值的两个数，并且打印出来

int find(int arr[], int target){
 int left = 0;//头指针
 int right = arr.length - 1;// 尾指针
 while(left < right){
 if(left + right == target){
 // 找到⽬标数，进⾏打印，这⾥我就不执⾏打印操作两
 }else if(left + right < target){
 left ++;
 }else{
 right --;
 }
 } }

```

## 判断单链表是否有环

```text
我们就可以设置⼀个慢指针和⼀个快指针来遍历这个链表。慢指针⼀次移动⼀个节点，⽽快指针⼀次移
动两个节点，如果该链表没有环，则快指针会先遍历完这个表，如果有环，则快指针会在第⼆次遍历时
和慢指针相遇。
```

## 如何⼀次遍历就找到链表中间位置节点

```text
⼀样是设置⼀个快指针和慢指针。慢的⼀次移动⼀个节点，⽽快的两个。在遍历链表的时候，当快指针
遍历完成时，慢指针刚好达到中点。
```

## 单链表中倒数第 k 个节点

```text
设置两个指针，其中⼀个指针先移动k个节点。之后两个指针以相同速度移动。当那个先移动的指针遍
历完成的时候，第⼆个指针正好处于倒数第k个节点。
```